{"version":3,"file":"index.js","sources":["../../src/state/state.ts","../../src/state/computed.ts","../../src/components/For.tsx"],"sourcesContent":["import { track, trigger } from \"./effect\";\n\nexport function state<T>(initialValue: T): { value: T };\nexport function state<T = undefined>(): { value: T | undefined };\nexport function state<T>(initialValue?: T): { value: T | undefined } {\n  const state = { value: initialValue };\n\n  return new Proxy(state, {\n    get(target, key, receiver) {\n      track(target, key);\n      return Reflect.get(target, key, receiver);\n    },\n    set(target, key, newValue, receiver) {\n      const oldValue = target[key as keyof typeof target];\n      const result = Reflect.set(target, key, newValue, receiver);\n\n      const isArray = Array.isArray(newValue);\n      const isObject =\n        typeof newValue === \"object\" &&\n        !Array.isArray(newValue) &&\n        newValue !== null;\n      const isPrimitive =\n        typeof newValue !== \"object\" && typeof newValue !== \"function\";\n\n      const shouldTrigger =\n        isArray || isObject || (isPrimitive && oldValue !== newValue);\n\n      if (shouldTrigger) {\n        trigger(target, key);\n      }\n\n      return result;\n    },\n  });\n}\n","import { effectify, track, trigger } from \"./effect\";\n\nexport function computed<T>(getter: () => T): { readonly value: T } {\n  let cachedValue: T;\n  let dirty = true;\n  let initialized = false;\n\n  const obj = {\n    get value(): T {\n      if (dirty) {\n        run();\n        dirty = false;\n      }\n      initialized = true;\n      track(obj, \"value\");\n      return cachedValue;\n    },\n    set value(_: unknown) {\n      throw new Error(\"Computed is read-only and cannot be modified\");\n    },\n  };\n\n  const run = effectify(() => {\n    cachedValue = getter();\n    dirty = false;\n\n    if (initialized) {\n      queueMicrotask(() => {\n        trigger(obj, \"value\");\n      });\n    }\n  });\n\n  return obj;\n}\n","import { effect } from \"../state\";\nimport { normalizeDom } from \"../util\";\n\ntype ForProps<T> = {\n  items: T[];\n  children: (item: T, index: number) => JSX.Element;\n  fallback?: JSX.Element;\n};\n\ntype ForPropsReal<T> = {\n  items: () => T[];\n  children: [() => (item: T, index: number) => JSX.Element];\n  fallback?: () => JSX.Element;\n};\n\ninterface RefNode extends Text {\n  mount?: (node: Node) => void;\n  unmount?: (node: Node) => void;\n}\n\nexport function For<T>(props: ForProps<T>) {\n  const {\n    items: each,\n    children: [children],\n    fallback: _fallback,\n  } = props as unknown as ForPropsReal<T>;\n\n  const $placeholder = document.createTextNode(\"\") as RefNode;\n  const $nodes = new Map<any, Node>();\n  const $fallback = _fallback?.();\n  let previousKeys: any[] = [];\n\n  $placeholder.mount = (anchor: Node) => {\n    effect(() => {\n      const $parent = anchor.parentNode;\n      if (!$parent) return;\n\n      const items = each();\n\n      // Remove old nodes that are no longer used\n      for (const oldKey of previousKeys) {\n        if (items.includes(oldKey)) {\n          continue;\n        }\n\n        const node = $nodes.get(oldKey);\n\n        if (node && $parent.contains(node)) {\n          $parent.removeChild(node);\n        }\n\n        $nodes.delete(oldKey);\n      }\n\n      // Insert nodes in correct order\n      let referenceNode: ChildNode | null = anchor.nextSibling;\n\n      for (let i = 0; i < items.length; i++) {\n        const item = items[i];\n\n        let $domNodes = $nodes.get(item);\n\n        if (!$domNodes) {\n          $domNodes = children()(item, i) as Node;\n          $nodes.set(item, $domNodes);\n        }\n\n        // Insert each node in the correct order\n        if ($domNodes !== referenceNode) {\n          $parent.insertBefore($domNodes, referenceNode);\n        }\n\n        // Update referenceNode to follow last inserted node\n        referenceNode = $domNodes?.nextSibling ?? null;\n      }\n\n      // Handle fallback\n      if ($fallback instanceof HTMLElement) {\n        if (!items.length && !$parent.contains($fallback)) {\n          $parent.insertBefore($fallback, anchor.nextSibling);\n        } else if (!!items.length && $parent.contains($fallback)) {\n          $parent.removeChild($fallback);\n        }\n      }\n\n      previousKeys = items;\n    });\n  };\n\n  $placeholder.unmount = (anchor: Node) => {\n    const parent = anchor.parentNode;\n    if (!parent) return;\n\n    for (const $node of $nodes.values()) {\n      if ($node && parent.contains($node)) {\n        parent.removeChild($node);\n      }\n    }\n  };\n\n  return $placeholder;\n}\n"],"names":["state","initialValue","target","key","receiver","track","newValue","oldValue","result","isArray","isObject","trigger","computed","getter","cachedValue","dirty","initialized","obj","run","_","effectify","For","props","each","children","_fallback","$placeholder","$nodes","$fallback","previousKeys","anchor","effect","$parent","items","oldKey","node","referenceNode","i","item","$domNodes","parent","$node"],"mappings":"2IAIO,SAASA,EAASC,EAA4C,CACnE,MAAMD,EAAQ,CAAE,MAAOC,CAAa,EAEpC,OAAO,IAAI,MAAMD,EAAO,CACtB,IAAIE,EAAQC,EAAKC,EAAU,CACzB,OAAAC,EAAMH,EAAQC,CAAG,EACV,QAAQ,IAAID,EAAQC,EAAKC,CAAQ,CAC1C,EACA,IAAIF,EAAQC,EAAKG,EAAUF,EAAU,CACnC,MAAMG,EAAWL,EAAOC,CAA0B,EAC5CK,EAAS,QAAQ,IAAIN,EAAQC,EAAKG,EAAUF,CAAQ,EAEpDK,EAAU,MAAM,QAAQH,CAAQ,EAChCI,EACJ,OAAOJ,GAAa,UACpB,CAAC,MAAM,QAAQA,CAAQ,GACvBA,IAAa,KAOf,OAFEG,GAAWC,GAHX,OAAOJ,GAAa,UAAY,OAAOA,GAAa,YAGbC,IAAaD,IAGpDK,EAAQT,EAAQC,CAAG,EAGdK,CACT,CACF,CAAC,CACH,CChCgB,SAAAI,EAAYC,EAAwC,CAClE,IAAIC,EACAC,EAAQ,GACRC,EAAc,GAElB,MAAMC,EAAM,CACV,IAAI,OAAW,CACb,OAAIF,IACFG,EAAI,EACJH,EAAQ,IAEVC,EAAc,GACdX,EAAMY,EAAK,OAAO,EACXH,CACT,EACA,IAAI,MAAMK,EAAY,CACpB,MAAM,IAAI,MAAM,8CAA8C,CAChE,CACF,EAEMD,EAAME,EAAU,IAAM,CAC1BN,EAAcD,IACdE,EAAQ,GAEJC,GACF,eAAe,IAAM,CACnBL,EAAQM,EAAK,OAAO,CACtB,CAAC,CAEL,CAAC,EAED,OAAOA,CACT,UCdgBI,EAAOC,EAAoB,CACzC,KAAM,CACJ,MAAOC,EACP,SAAU,CAACC,CAAQ,EACnB,SAAUC,CACZ,EAAIH,EAEEI,EAAe,SAAS,eAAe,EAAE,EACzCC,EAAS,IAAI,IACbC,EAAYH,IAAY,EAC9B,IAAII,EAAsB,GAE1B,OAAAH,EAAa,MAASI,GAAiB,CACrCC,EAAO,IAAM,CACX,MAAMC,EAAUF,EAAO,WACvB,GAAI,CAACE,EAAS,OAEd,MAAMC,EAAQV,EAAK,EAGnB,UAAWW,KAAUL,EAAc,CACjC,GAAII,EAAM,SAASC,CAAM,EACvB,SAGF,MAAMC,EAAOR,EAAO,IAAIO,CAAM,EAE1BC,GAAQH,EAAQ,SAASG,CAAI,GAC/BH,EAAQ,YAAYG,CAAI,EAG1BR,EAAO,OAAOO,CAAM,CACtB,CAGA,IAAIE,EAAkCN,EAAO,YAE7C,QAASO,EAAI,EAAGA,EAAIJ,EAAM,OAAQI,IAAK,CACrC,MAAMC,EAAOL,EAAMI,CAAC,EAEpB,IAAIE,EAAYZ,EAAO,IAAIW,CAAI,EAE1BC,IACHA,EAAYf,EAAS,EAAEc,EAAMD,CAAC,EAC9BV,EAAO,IAAIW,EAAMC,CAAS,GAIxBA,IAAcH,GAChBJ,EAAQ,aAAaO,EAAWH,CAAa,EAI/CA,EAAgBG,GAAW,aAAe,IAC5C,CAGIX,aAAqB,cACnB,CAACK,EAAM,QAAU,CAACD,EAAQ,SAASJ,CAAS,EAC9CI,EAAQ,aAAaJ,EAAWE,EAAO,WAAW,EACvCG,EAAM,QAAUD,EAAQ,SAASJ,CAAS,GACrDI,EAAQ,YAAYJ,CAAS,GAIjCC,EAAeI,CACjB,CAAC,CACH,EAEAP,EAAa,QAAWI,GAAiB,CACvC,MAAMU,EAASV,EAAO,WACtB,GAAKU,EAEL,UAAWC,KAASd,EAAO,OAAO,EAC5Bc,GAASD,EAAO,SAASC,CAAK,GAChCD,EAAO,YAAYC,CAAK,CAG9B,EAEOf,CACT"}